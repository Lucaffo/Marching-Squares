#pragma kernel March

struct Triangle 
{
    // Vertices
    float2 vertexA;
    float2 vertexB;
    float2 vertexC;

    // UVS
    float2 aUV;
    float2 bUV;
    float2 cUV;
};

struct VoxelData
{
    float2 position;
    float isoValue;
};

AppendStructuredBuffer<Triangle> triangles;
RWStructuredBuffer<VoxelData> voxels;

int cells;
float isoLevel;
bool useInterpolation;

float2 lerp(float2 a, float2 b, float w)
{
  return a + w*(b-a);
}

void AddTriangle(float2 a, float2 b, float2 c)
{
    Triangle tri;
    tri.vertexA = a;
    tri.vertexB = b;
    tri.vertexC = c;

    tri.aUV = float2(1, 0) * a.x + float2(0, 1) * a.y;
    tri.bUV = float2(1, 0) * b.x + float2(0, 1) * b.y;
    tri.cUV = float2(1, 0) * c.x + float2(0, 1) * c.y;

    triangles.Append(tri);
}

void AddQuad(float2 a, float2 b, float2 c, float2 d)
{
    AddTriangle(a, b, c);
    AddTriangle(a, c, d);
}

void AddPentagon(float2 a, float2 b, float2 c, float2 d, float2 e)
{
    AddTriangle(a, b, c);
    AddTriangle(a, c, d);
    AddTriangle(a, d, e);
}

[numthreads(128, 1, 1)]
void March (int3 id : SV_DispatchThreadID)
{   
    if (id.x > cells * cells + cells - 2)
    {
        return;
    }

    uint index = id.x;

    // Cell corners
    VoxelData a = voxels[index];
    VoxelData b = voxels[index + 1];
    VoxelData c = voxels[index + cells + 1];
    VoxelData d = voxels[index + cells + 2];

    // Calculate unique index for each cube configuration.
    // There are 16 possible values
    int cellType = 0; 
    if (a.isoValue > isoLevel) cellType |= 1;
    if (b.isoValue > isoLevel) cellType |= 2;
    if (c.isoValue > isoLevel) cellType |= 4;
    if (d.isoValue > isoLevel) cellType |= 8;

    // Instead of top you lerp between A and B to get the position.
    // Instead of right you lerp between B and C, etc.
    // 
    //          top
    //       C-------D
    //  left |       |  right
    //       |       |
    //       A-------B
    //         bottom

    // Interpolation part
    float t_top;
    float t_right;
    float t_bottom;
    float t_left;

    if(useInterpolation)
    {
        t_top = (isoLevel - c.isoValue) / (d.isoValue - c.isoValue);
        t_right = (isoLevel - d.isoValue) / (b.isoValue - d.isoValue);
        t_bottom = (isoLevel - b.isoValue) / (a.isoValue - b.isoValue);
        t_left = (isoLevel - a.isoValue) / (c.isoValue - a.isoValue);
    }
    else
    {
        // Interpolation is for edge vertex
        t_top = 0.5;
        t_right = 0.5;
        t_bottom = 0.5;
        t_left = 0.5;
    }

    float2 top = lerp(c.position, d.position, t_top); 
    float2 right = lerp(d.position, b.position, t_right);
    float2 bottom = lerp(b.position, a.position, t_bottom);
    float2 left = lerp(a.position, c.position, t_left);

    switch(cellType)
    {
        case 0:
            return;
        case 1:
            AddTriangle(a.position, left, bottom);
            return;
        case 2:
            AddTriangle(b.position, bottom, right);
            return;
        case 4:
            AddTriangle(c.position, top, left);
            return;
        case 8:
            AddTriangle(d.position, right, top);
            return;
        case 3:
            AddQuad(a.position, left, right, b.position);
            return;
        case 5:
            AddQuad(a.position, c.position, top, bottom);
            return;
        case 10:
            AddQuad(bottom, top, d.position, b.position);
            return;
        case 12:
            AddQuad(left, c.position, d.position, right);
            return;
        case 15:
            AddQuad(a.position, c.position, d.position, b.position);
            return;
        case 7:
            AddPentagon(a.position, c.position, top, right, b.position);
            return;
        case 11:
            AddPentagon(b.position, a.position, left, top, d.position);
            return;
        case 13:
            AddPentagon(c.position, d.position, right, bottom, a.position);
            return;
        case 14:
            AddPentagon(d.position, b.position, bottom, left, c.position);
            return;
        case 6:
            AddTriangle(b.position, bottom, right);
            AddTriangle(c.position, top, left);
            return;
        case 9:
            AddTriangle(a.position, left, bottom);
            AddTriangle(d.position, right, top);
            return;
    }
}