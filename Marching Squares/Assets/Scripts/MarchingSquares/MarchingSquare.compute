#pragma kernel March

struct VoxelData
{
    float3 position;
    float isoValue;
};

// Append buffers for each data types
RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<int> triangles;

RWStructuredBuffer<VoxelData> voxels;

int cells;
float isoLevel;
bool useInterpolation;

float3 lerp(float3 a, float3 b, float w)
{
    return a + w*(b-a);
}

void AddTriangle(int i, float3 a, float3 b, float3 c)
{
    // Set the triangle vertices
    vertices[i] = a;
    vertices[i + 1] = b;
    vertices[i + 2] = c;

    // Set the triangles indexes
    triangles[i] = i;
    triangles[i + 1] = i + 1; 
    triangles[i + 2] = i + 2;
}

void AddQuad(int i, float3 a, float3 b, float3 c, float3 d)
{
    // Set the triangle vertices
    vertices[i] = a;
    vertices[i + 1] = b;
    vertices[i + 2] = c;
    vertices[i + 3] = d;

    // Set the triangles indexes
    triangles[i] = i;
    triangles[i + 1] = i + 1; 
    triangles[i + 2] = i + 2;

    triangles[i + 3] = i;
    triangles[i + 4] = i + 2; 
    triangles[i + 5] = i + 3;
}

void AddPentagon(int i, float3 a, float3 b, float3 c, float3 d, float3 e)
{
    // Set the triangle vertices
    vertices[i] = a;
    vertices[i + 1] = b;
    vertices[i + 2] = c;
    vertices[i + 3] = d;
    vertices[i + 4] = e;

    // Set the triangles indexes
    triangles[i] = i;
    triangles[i + 1] = i + 1; 
    triangles[i + 2] = i + 2;

    triangles[i + 3] = i;
    triangles[i + 4] = i + 2; 
    triangles[i + 5] = i + 3;

    triangles[i + 6] = i;
    triangles[i + 7] = i + 3; 
    triangles[i + 8] = i + 4;
}

void AddDoubleTriangles(int i, float3 a, float3 b, float3 c, float3 a1, float3 b1, float3 c1)
{
    // Set the triangle vertices
    vertices[i] = a;
    vertices[i + 1] = b;
    vertices[i + 2] = c;
    vertices[i + 3] = a1;
    vertices[i + 4] = b1;
    vertices[i + 5] = c1;

    // Set the triangles indexes
    triangles[i] = i;
    triangles[i + 1] = i + 1; 
    triangles[i + 2] = i + 2;

    // Set the triangles indexes
    triangles[i + 3] = i + 3;
    triangles[i + 4] = i + 4; 
    triangles[i + 5] = i + 5;
}

[numthreads(128, 1, 1)]
void March (int3 id : SV_DispatchThreadID)
{   
    if (id.x > cells * cells + cells - 2)
    {
        return;
    }

    int index = id.x;

    // Cell corners
    VoxelData a = voxels[index];
    VoxelData b = voxels[index + 1];
    VoxelData c = voxels[index + cells + 1];
    VoxelData d = voxels[index + cells + 2];

    // Transform the index into the triangle/vertices index
    index *= 9;

    // Calculate unique index for each cube configuration.
    // There are 16 possible values
    int cellType = 0; 
    if (a.isoValue > isoLevel) cellType |= 1;
    if (b.isoValue > isoLevel) cellType |= 2;
    if (c.isoValue > isoLevel) cellType |= 4;
    if (d.isoValue > isoLevel) cellType |= 8;

    // Instead of top you lerp between A and B to get the position.
    // Instead of right you lerp between B and C, etc.
    // 
    //          top
    //       C-------D
    //  left |       |  right
    //       |       |
    //       A-------B
    //         bottom

    // Interpolation part
    float t_top;
    float t_right;
    float t_bottom;
    float t_left;

    if(useInterpolation)
    {
        t_top = (isoLevel - c.isoValue) / (d.isoValue - c.isoValue);
        t_right = (isoLevel - d.isoValue) / (b.isoValue - d.isoValue);
        t_bottom = (isoLevel - b.isoValue) / (a.isoValue - b.isoValue);
        t_left = (isoLevel - a.isoValue) / (c.isoValue - a.isoValue);
    }
    else
    {
        // Interpolation is for edge vertex
        t_top = 0.5;
        t_right = 0.5;
        t_bottom = 0.5;
        t_left = 0.5;
    }

    float3 top = lerp(c.position, d.position, t_top); 
    float3 right = lerp(d.position, b.position, t_right);
    float3 bottom = lerp(b.position, a.position, t_bottom);
    float3 left = lerp(a.position, c.position, t_left);

    switch(cellType)
    {
        case 0:
            return;
        case 1:
            AddTriangle(index, a.position, left, bottom);
            return;
        case 2:
            AddTriangle(index, b.position, bottom, right);
            return;
        case 4:
            AddTriangle(index, c.position, top, left);
            return;
        case 8:
            AddTriangle(index, d.position, right, top);
            return;
        case 3:
            AddQuad(index, a.position, left, right, b.position);
            return;
        case 5:
            AddQuad(index, a.position, c.position, top, bottom);
            return;
        case 10:
            AddQuad(index, bottom, top, d.position, b.position);
            return;
        case 12:
            AddQuad(index, left, c.position, d.position, right);
            return;
        case 15:
            AddQuad(index, a.position, c.position, d.position, b.position);
            return;
        case 7:
            AddPentagon(index, a.position, c.position, top, right, b.position);
            return;
        case 11:
            AddPentagon(index, b.position, a.position, left, top, d.position);
            return;
        case 13:
            AddPentagon(index, c.position, d.position, right, bottom, a.position);
            return;
        case 14:
            AddPentagon(index, d.position, b.position, bottom, left, c.position);
            return;
        case 6:
            AddDoubleTriangles(index, b.position, bottom, right, c.position, top, left);
            return;
        case 9:
            AddDoubleTriangles(index,a.position, left, bottom, d.position, right, top);
            return;
    }
}